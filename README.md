1.
In this exercise, I built a custom smart pointer by creating a template class that acts as a secure wrapper for heap memory, ensuring that resources are managed automatically through the principle of RAII. By implementing a destructor that calls delete, I guaranteed that memory is freed the moment the pointer goes out of scope, preventing leaks. To maintain exclusive ownership, I "killed" the copy constructor to block dangerous duplicates and implemented move semantics via the && operator, which allows me to "steal" the memory address from an old pointer and set it to nullptr. This strategic hand-off ensures that only one object ever owns the data, preventing the "double-free" crash that occurs when the same memory is deleted twice, ultimately turning a risky raw pointer into a safe, high-performance tool.